Notes while coding:

----------
11.04.2023
----------
The way the PModel:modelByPrimaryId(--wanted id number---, database), returns what's inside the PModel for a certain ID

I want instead of returning what inside model, to retrun what inside the dependencies, i.e. representationType and  strucutreTechnique

constructor/descruptor 
-- For the Warning (inheretge etc)
	-- the descrucotr ~PModel must virtual 


-- Put 	
virtual std::string sqlIdName()
{
	return staticSqlIDName(); 	
}
to Object, bevause is Used to every retrieving


-- Need to INSERT something to BondBase and Coarsegrain so you can test stuff

----------
13.04.2023
----------
-- INSERT something to BondBase and Coarsegrain so you can test stuff
-- what did we change last time so we can print stuff from res?
-- add the Utility::checkIfEmpty to the other as well
	- is it same to return zero? 
	- maybe instead of return zeor it should break?
-- Continue with retirveal: PData 

----------
17.04.2023
----------
-- What if I wan tto retrivev the rest, even thought this particular one doesn't exist?
--structuretechnique and repretype have different, but equally correct implementation of 
retrieveDependencies. Just need to keep only one of them. 
-- I removed wht i have wrote in the RepresentationType::fillInFromResults. I don't 
know if it right as it is at the moment, I need to rethink about this. Same goes for 
PData::fillInFromResults
--std::string PData::selectQueryDataByInfo(DataEnum dat), in line 78: the selectQuery mmust be ast
the one in the last commit. Check that and correct
-- void RepresentationType::fillInFromResults(const Result &res) doesn't nmeed to be there 
apparently
-- for tomorrow: build DataCryoEMInfo::atomicModelByPrimaryId(std::stoi(res[datCryo_id]), db);
etc and make some tests
-- I removed setDataInfo() form PData.h cause it was causing a liner error, but 
it should be on the latest commit, so got and add that back 
-- write RetrieveByDatInfo in PData 
-- there is a contrain in data: you can only have one kind of data at times

----------
18.04.2023
----------
-- Rewrite StructureTechniqueInfo::retrieveDependencies  with the "format" of PData
-- retriveing for maps: result.at("comments")
-- make some test to retrievign e.g. pdf name from files
-- use the insert template you have made
-- write the "fillInFromResults" to other if it's missing 

----------
19.04.2023
----------
-- There is an issue with nmrqualityData and the dependencies on this one, so for now i removed the dependencies. it runs smoothly.
-- I should fill up the dataabase with inserts 

----------
20.04.2023
----------
-- Find a correct way to present the results 
-- continue with the cascade of PDat
-- PRESENTATION


-- Make a Utility  (or maybe just in model or Pmodel):
	-- std::cout << model << std::endl;
-- and ModelDataPair to the retrieve cascade 
-- !!!!!!templating!!!!!!


----------
26.04.2023
----------

-- The goal is to make template Archive that it will be able to recognise if an id already exists and return existing pointer form archive, if the id exists
	-- The result of this implementaiton is that when I am running the test, if a 
	call two models with the same id numbers, the returned models should be the same.  

-- Additionally, to do: 
	-- Move the functionality of modelByPrimaryId , datatByPrimaryId, etc to objectByPrimaryId(int, db) (as seen in my notes)
	-- change modelByPrimaryId() as seen bellow

-- What is the "safest" way of start building Arhcive, without messing the 
wokring implementation too much?



PModel* PModel::modelByPrimaryId(int id, Database *db)
{
	Object* obj = objectByPriamryId(int if, db)
	PModel *ptr = static_cast<Pmodel*> (obj);

	return ptr;
}

----------
02.05.2023
----------

-- to some tables that they don't have dependencies, I should leave the 
"INSERT default" query. 
-- Make more tests. Understand the cache code and the use of the cache. 
-- Move the functionality of modelByPrimaryId, datatByPrimaryId, etc to objectByPrimaryId(int, db) (as seen in my notes)
-- Is that note still relevant??? "change modelByPrimaryId() as seen bellow:"
PModel* PModel::modelByPrimaryId(int id, Database *db)
{
	Object* obj = objectByPriamryId(int if, db)
	PModel *ptr = static_cast<Pmodel*> (obj);

	return ptr;
}
-- Think about how to implement the Collection cascade 

----------
08.05.2023
----------
-- Need to have an implementation on objectByPrimarYId to every subclass, otherwise I get an erro
	-- BUT WHY??????
-- Do tha tofr know for everyhting so I can check if it works and discuss with Helen.
-- IS THSI MAYBE HELPFUL: 

PModel* PModel::modelByPrimaryId(int id, Database *db)
{
	Object* obj = objectByPriamryId(int id, db)
	PModel *ptr = static_cast<Pmodel*> (obj);

	return ptr;
}

----------
09.05.2023
----------
-- Is the objectPair returned from Cache contain the right values? 
-- check tables CryoEmDatainfo
-- check tbale crystal
-- check table crystallographicdatinfo
-- fix the interface Data.h and Model.h
-- remove Group.h and Grouphasdataset
-- Where is the table Rafactros_info?????
-- Do I have two rfactors info in src?
-- need to deal with the  warnings


----------
10.05.2023
----------
-- start over: delete all uncessary stuff for the derived classes
-- add  to virtual members in the derived classes

----------
11.05.2023
----------
-- When is override nessecary?
-- COMMIT
-- there is somehting weird with RfactorsInfo. Find were do you initialise this table from. maybe there is the issue
-- COLLECTION and COLLECTIONHASDATASET
-- probably I will find more issues when I start running with Pdata, so befire moving to COllection, 
make sure tha both Pdata and PModel works correctly
-- Then try with ModelDataPair and then move to Collection 
--Maybe you will need to isnert some values manually to ModelDataPair and COllection etc 
